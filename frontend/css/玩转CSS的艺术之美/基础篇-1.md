# 学前准备
学习 `CSS` 的秘诀:
+ 根据 `类型` 将属性分类并记忆
+ 根据 `功能` 将选择器分类并记忆
+ 将效果粒度化。将效果以组件形式拆分，分析其细节是否可由 `CSS` 实现，由下往上分析并组装，若每个组件都能由 `CSS` 实现，则大体就能由 `CSS` 实现
+ 放弃 `JS` 实现效果的固有化思维
+ 多浏览设计类网站

# 基础: 浏览器

## 渲染引擎
渲染引擎又称为浏览器内核，指负责对网页语法解析并渲染为一张可视化页面的解析器，它是浏览器最核心的部位，不同内核对网页语法的解析也有不同，因此同一网页语法在不同内核的浏览器中的渲染效果也可能不同，这就是**浏览器差异性**

> 世界五大浏览器 : `Chrome` / `Safari` / `Firefox` / `Opera` / `IExplorer/Edge`

## 渲染过程

要了解浏览器网页的渲染过程，首先得知道 `关键渲染路径` : 浏览器从最初接收请求得到 `HTML` / `CSS` / `JS` 等资源，然后解析、构建、渲染、布局、绘制和合成，到最后呈现在用户眼前的整个过程

将关键渲染路径划分理解，那网页的渲染过程可分为以下部分
+ **解析文件**
    + `DOM 树` : 将 `html 文件` 转换为 `DOM 树`
    + `CSSOM 树` : 将 `CSS 文件` 转换为 `CSSOM 树`
    + `渲染树` : 将 `DOM 树`与 `CSSOM 树` 合并生成 `渲染树`
+ **绘制图层**
    + `回流` : 根据渲染树生成布局渲染树
    + `重绘` : 根据布局渲染树生成绘制渲染树
+ **合成图层** : 根据绘制渲染树合成图层显示在屏幕中

### 解析文件
在构建 `DOM 树` 时，当 `HTML  解析器` 遇到 `<script>` 时会立即阻塞 `DOM 树` 的构建，将控制权移交给浏览器的 `JS 引擎`，等到 `JS 引擎` 运行完毕，浏览器才会从中断的地方恢复 `DOM 树` 的创建

> 浏览器的渲染引擎将 `DOM 树` 和 `CSSOM 树` 合并生成渲染树，只渲染需要显示的节点及样式。`DOM 树` / `CSSOM 树` / `渲染树` 三者的构建并无先后条件与先后顺序，非完全独立而是存在交叉并行构建的情况，因此会形成一边加载、一边解析、一边渲染的工作现象


### 绘制图层
进入绘制阶段，遍历渲染树，调用渲染器的 `paint()` 在屏幕中绘制内容。根据渲染树布局计算样式，即每个节点在网页中的布局、尺寸等几何属性。`HTML` 默认是流式布局，`CSS`  和 `JS` 会打破这种布局，改变 `DOM` 的几何属性与外观属性。在绘制时根据渲染树布局，再根据布局绘制，这就是**回流重绘**
+ 回流 : 改变几何属性的渲染
+ 重绘 : 改变外观属性而不影响几何属性的渲染

### 合成图层
将回流重绘生成的图层逐张合并且显示在屏幕中。上述几个步骤并非一次性顺序完成，若改动 `DOM/CSSOM` ，上述过程会被重新执行。总之用户的交互操作引发了网页的重渲染

## 网页兼容性
网页兼容性是指网页在各种浏览器中的显示效果可能不同而产生浏览器与网页间的兼容问题

> 遇到陌生的 `CSS` 属性与选择器可以使用 [`Caniuse`](https://caniuse.com/) 查看它们的兼容性

### [磨平浏览器默认样式](https://github.com/necolas/normalize.css/blob/master/normalize.css)
每个浏览器的 `CSS` 默认样式不尽相同，所以最简单有效的方式是对其默认样式初始化

### 加入浏览器私有属性
通常编写 `CSS`  都会在一些 `CSS3` 属性前加入 `-webkit-` / `-moz-` / `-ms-` / `-o` 等，这些就是浏览器私有属性

> 出现私有属性是因为制定 `CSS` 标准的 `W3C` 组织公布标准属性需要走很严格复杂的流程，浏览器厂商一般会加私有属性提前支持某种属性

对于编写私有属性的顺序需要特别注意: **兼容性写法放到前面，标准性写法放到最后**

```css
/* Chrome、Safari、New Opera、New Edge */
-webkit-transform: translate(10px, 10px);
/* Firefox */
-moz-transform: translate(10px, 10px);
/* IExplorer、Old Edge */
-ms-transform: translate(10px, 10px);
/* Old Opera */
-o-transform: translate(10px, 10px);
/* 标准 */
transform: translate(10px, 10px);
```

每个 `CSS3` 属性都编写上述兼容性代码无疑是浪费生命，在使用 `webpack` 打包代码时可以接入 `postcss-loader` 与 `postcss-preset-env`，可以根据 `Caniuse` 提供的数据对代码中的 `CSS3`  属性批量加入私有属性

> 不搞 `IExplorer` 兼容，那就无兼容问题

# 基础: 回流重绘

## 回流
回流又称为**重排**，指改变几何属性的渲染

回流意味着节点的几何属性改变，需要重新计算并生成渲染树，导致渲染树的全部或部分发生变化

## 重绘
重绘是指改变外观属性而不影响几何属性的渲染，渲染树的节点发生改变，但是不影响节点的几何属性。由此可见回流对浏览器性能的消耗高于重绘且***回流一定伴随重绘，重绘却不一定伴随回流***

## 属性分类
+ 几何属性: 包括布局、尺寸等可用数学几何衡量的属性
  | 布局 | 尺寸 |
  | -- | -- |
  | `display` `float` `position` `list` `table` `flex` `grid` `columns` | `margin` `padding` `border` `width` `height` |

+ 外观属性: 包括界面、文字等可用状态向量描述的属性
  | 界面 | 文字 |
  | -- | -- |
  | `appearance` `outline` `background` `mask` `box-shadow` `box-reflect` `filter` `opacity` `clip` | `text` `font` `word` |

## 性能优化
尽量减少回流重绘，就是 `CSS` 性能优化中一个很好的指标

### 使用 `visibility: hidden` 替换 `display: none`

|  | VH | DN |
| -- | -- | -- |
| 占位表现 | 占据空间 | 不占据空间 |
| 触发影响 | 重绘 | 回流重绘 |
| 过渡影响 | 不影响过渡，不影响动画 | 影响过渡，不影响动画 |
| 株连效果 | 自身及其子节点全都不可见，但可声明子节点 `visibility: visible` 单独显示 | 自身及其子节点全都不可见 |

### 使用 `transform` 替代 `top`
`top` 是几何属性，操作 `top` 会改变节点位置引发回流，使用 `transform: translate3d(x,0,0)` 替代 `top` 只会引发图层重绘，还会间接启动 `GPU` 加速

### 避免使用 `Table` 布局
可能很小的一个改动就会造成整个 `<table>` 的回流，通常用 `<ul>` / `<li>` / `<span>` 等标签替代 `table` 系列标签生成表格

### 避免规则层级过多
浏览器的 `CSS` 解析器解析 `CSS` 文件时，对 `CSS` 规则是从右到左匹配查找，样式层级过多会影响回流重绘效率，建议保持 `CSS`  规则在 `3` 层左右

### 避免节点属性值放在循环中当成循环变量

```js
for (let i = 0; i < 66666; i++) {
	const top = document.getElementById("css").style.top;
	console.log(top);
}
```
应在循环外部使用变量保存一些不会变化的 `DOM`  映射值

```js
const top = document.getElementById("css").style.top;
for (let i = 0; i < 66666; i++) {
	console.log(top);
}
```

### [动态改变类而不改变样式](https://www.runoob.com/jsref/prop-element-classlist.html)
不要尝试每次操作 `DOM` 改变节点样式，这样会频繁触发回流，更好的方式是使用新的类名预设节点样式，在执行逻辑操作时收集并确认最终更换的类名集合，在适合时机一次性动态替换原来的类名集合

### 将频繁回流重绘的节点设置为图层
渲染过程最后一步提到将回流重绘生成的图层逐张合并且显示在屏幕中，可将其理解成 `Photoshop` 的图层，如果不对图层添加关联，图层间不会相互影响。同理在浏览器中设置频繁回流重绘的节点为一张新图层，那么新图层就能够阻止节点的渲染行为影响别的节点，这张图层中如何变化都无法影响到其他图层

设置新图层有两种方式
1. 将节点设置为 `<video>` 或 `<iframe>`
1. 为节点声明 `will-change`

### 使用 `requestAnimationFrame` 作为动画帧
动画速度越快，回流次数越多，浏览器刷新频率为 `60Hz`，即每 `16.6ms` 更新一次，而 `requestAnimationFrame()` 正是以这个速度更新一次，所以可以用 `requestAnimationFrame()` 替代 `setInterval()`